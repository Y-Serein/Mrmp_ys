# Y_Serein第2章作业

> 本文档记录移动机器人运动规划第2章作业，主要工作内容为A*算法的部署、不同启发式函数的比较、JPS与A\*算法的比较。

## 仿真环境：

> 虚拟机软件：VMware17.5

> Ubuntu系统版本：20.04(ROS noetic)

> 仿真软件：Rviz

> 优先级队列：std::multimap，即按 fScore（节点总代价）排序


## 操作回顾

- 下载与编译工程：

  > 创建ros工作空间目录与功能包目录：
  >
  > > ```bash
  > > mkdir -p ~/slam_ws/src
  > > # 将hw/src中的三个文件夹复制到/slam_ws/src路径下
  > > # 直接编译会存在一些或由于编译环境不同导致的的报错，需要修改一些配置
  > > gedit ~/slam_ws/src
  > > gedit ~/slam_ws/src/grid_path_searcher/src/demo_node.cpp
  > > # 检索world-> 将107行的/world修改为world->保存->关闭
  > > gedit ~/slam_ws/src/grid_path_searcher/CMakeLists.txt
  > > # 将第29行的C++11修改为C++14->保存->关闭
  > > ```
  >
  > 初始化工作空间：
  >
  > > ```bash
  > > cd ~/slam_ws/src
  > > catkin_init_workspace
  > > ```
  >
  > 编译工作空间：
  >
  > > ```bash
  > > cd ~/slam_ws/
  > > catkin_make
  > > ```
  >
  > 配置环境变量：
  >
  > > ```bash
  > > echo "source ~/slam_ws/devel/setup.bash" >> ~/.bashrc
  > > source ~/.bashrc
  > > ```

- 运行工程

  > ```bash
  > # 新建第一个终端(键入Ctrl+Alt+T)
  > roscore
  > # 新建第二个终端
  > roslaunch grid_path_searcher demo.launch
  > ```


## RViz 可视化结果截图：



> ![image-20250809101509036](Image_ys/image-20250809101509036.png)

> ![image-20250809102032087](Image_ys/image-20250809102032087.png)



## 算法流程说明 + 流程图



- 流程图

  > ![](Image_ys/4-3 A算法流程图.drawio (1)-1754722770239-3.png)



## 关于不同启发式函数（Manhattan、Euclidean、Diagonal）效率比较

> 基于Manhattan、Euclidean、Diagonal三种不同的启发式函数路径搜索结果分别如表1、表2、表3所示，由于生成地图存在随机性，将每种启发式函数测试五次取平均值以降低测试结果的偶然性

- 表1 ：基于Manhattan的启发式函数的五次路径搜索结果表

| Manhattan | 时间消耗 (ms) |  路径成本 (m)  | 访问节点数量 |
| :-------: | :-----------: | :------------: | :----------: |
|     1     |   13.139357   | 6710886.200000 |    54148     |
|     2     |   17.384210   | 6710886.200000 |    54148     |
|     3     |   16.787100   | 1677721.400000 |    46490     |
|     4     |   18.310023   | 3355443.000000 |    50243     |
|     5     |   10.643385   | 838860.600000  |    42696     |
|  平均值   |   15.252815   | 3658759.480000 |    49545     |



- 表2 ：基于Euclidean的启发式函数的五次路径搜索结果表

| Euclidean | 时间消耗 (ms) |  路径成本 (m)  | 访问节点数量 |
| :-------: | :-----------: | :------------: | :----------: |
|     1     |   15.030339   | 1677721.400000 |    45674     |
|     2     |   8.806346    | 209715.000000  |    35106     |
|     3     |   16.094501   | 1677721.400000 |    45674     |
|     4     |   13.550085   | 3355443.000000 |    49400     |
|     5     |   14.880853   | 3355443.000000 |    49400     |
|  平均值   |   13.672425   | 2015608.760000 |   45050.8    |



- 表3：基于Diagonal的启发式函数的五次路径搜索结果表

| Diagonal | 时间消耗 (ms) |  路径成本 (m)   | 访问节点数量 |
| :------: | :-----------: | :-------------: | :----------: |
|    1     |   15.098660   | 1677721.400000  |    44392     |
|    2     |   13.292235   | 1677721.400000  |    44392     |
|    3     |   20.211770   | 13421772.600000 |    55514     |
|    4     |   18.845413   | 6710886.200000  |    52228     |
|    5     |   16.201395   | 3355443.000000  |    48238     |
|  平均值  |  16.7298946   |   4282608.88    |   48952.8    |



- 通过对比三种不同的启发式函数路径搜索结果可以得到，基于Euclidean的启发式函数的路径成本与访问节点数量优于基于Manhattan的启发式函数和基于Diagonal的启发式函数，基于Euclidean的启发式函数在允许任意方向移动时能更准确地反映实际最短路径，所以路径成本通常较低，基于Manhattan的启发式函数仅允许水平和垂直移动，所以得到的访问节点数量较高，基于Diagonal的启发式函数访问节点数量较于两者之间，符合对角距离的在曼哈顿距离与欧几里得距离之间的特征。





## 是否使用 Tie Breaker 的效果比较分析



- 表4：基于Euclidean的启发式函数且使用 Tie Breaker策略的五次路径搜索结果表

| Tie Breaker | 时间消耗 (ms) |  路径成本 (m)  | 访问节点数量 |
| :---------: | :-----------: | :------------: | :----------: |
|      1      |   11.586989   | 1677721.400000 |    46848     |
|      2      |   16.899184   | 1677721.400000 |    46848     |
|      3      |   15.449655   | 1677721.400000 |    46848     |
|      4      |   11.072625   | 419430.200000  |    38823     |
|      5      |   17.333511   | 3355443.000000 |    51085     |
|   平均值    |  14.4683928   |   1657611.2    |   46088.4    |



- 通过对比表2与表4数据，在目前的环境中，使用Tie Breaker策略能够一定程度上降低路径成本与访问节点数量。





## JPS 与 A* 在不同地图条件下的效率对比

- JPS 算法与 A*算法共同运行结果如图3所示

  > ![image-20250809150301003](Image_ys/image-20250809150301003.png) 

- 表5（1）：A*算法与JPS算法 在不同地图条件下的效率对比表

| A*算法运行次数 | 时间消耗 (ms) |  路径成本 (m)  | 访问节点数量 |
| :------------: | :-----------: | :------------: | :----------: |
|       1        |   16.149718   | 3355443.000000 |    51048     |
|       2        |   13.826861   | 3355443.000000 |    51048     |
|       3        |   11.542670   | 1677721.400000 |    47253     |
|       4        |   15.020218   | 838860.600000  |    43580     |
|       5        |   13.292102   | 1677721.400000 |    47253     |
|   A* 平均值    |  13.9663138   |   2180937.8    |   48036.4    |



- 表5（2）：A*算法与JPS算法 在不同地图条件下的效率对比表

| JPS算法运行次数 | 时间消耗 (ms) | 路径成本 (m) | 访问节点数量 |
| :-------------: | :---------------: | :----------: | :----------: |
| 1               |  11.416364     | 5.360624     | 8455         |
| 2               |  8.815928      | 5.882697     | 11672        |
| 3               |  13.090286     | 6.364714     | 13446        |
| 4               |  12.485484     | 6.345439     | 12884        |
| 5               |  15.905032     | 6.096910     | 15289        |
| JPS 平均值      | 12.3426188    | 6.0100768    | 12349.2      |



- JPS 与 A* 在不同地图条件下的效率对比如表5所示，在简单直连的路径中（运行次数3和运行次数5），A\*算法较于JPS算法的时间消耗更底；在相对复杂的路径中，JPS算法较于A\*算法时间消耗更低。JPS算法整体路径成本与访问节点数量相较于A\*算法更低。

